package ru.ifmo.lessons.lesson26;

import com.sun.source.tree.CaseTree;

import java.util.List;
import java.util.concurrent.*; // 2. Все что связано с пулами потоков находится вот в этом пакете.

public class TaskExecutor {
    public static void main(String[] args) {
        // 1. Пул потоков - реализация порождающего паттерна проектирования - "объектный пул"
        // 1. Пул потоков [thread1, thread2, thread3,] это некоторое хранилище где уже созданные экземпляры класса thread, ждут когда к ним обратяться.
        // 1. Очередь с задачами [task1, task2, task3, task4]
        // 1. ервый поток выполняют задачу №1, второй 2, третий 3, когда один из потоков закончил он берет задачу 4.
        // 1. Пул потоков, можно реализовать самостоятельно или воспользоваться готовым пулом потоков
        // 1. Пул можно создать самостоятельно:
        // 1.1. фиксированного размера, количество потоков указывается при создании.
        // 1.2. Гибкий пул, когда размер будет колебаться от мин.(изначальное) до макс. Ex. min 2 max 8.
        // 1.3. Пул для выполнения задач с указанным интервалом.
        // 1.4. можно расшить (наследоваться- extend) существующий класс (пул потоков) для более гибкой настройки.
        // 1.5. можно имплементировать интерфейс пула потоков, для полностью своей реализации. Используется редко.
        // 1. Если задачи очень разные, то лучше сделать несколько пулов ex. одна задача, сложение, вторая передача в файл, третья еще что то, вообщем лучше иметь один пул под однотипные задачи.
        // 1. NB Проблема пула потоков: Допустим в пуле два потока, первая задача получает задачи от пользователя, тогда первый поток ждет ввода данных, вторая задача бесконечный цикл, тогда второй поток все время занят, таким образом задачи 3, 4, 5 не будут выполены.
        // 1. NB Решение: НЕ передам в пул потоков бесконечный цикл, надо использовать отдельный цикл. И все взоимодействие с клиентом это то же не про пул потоков.
        // 1. NB Перерасход ресурсов, происходит если размер потока очень большой (мало задач), мы ошиблись!
        // 1. Еще одна проблема, при СОБСТВЕННОЙ реализации это утечка потока, поток берет задачу и уходит ее выполнять, второй поток так же занят задачей 2, при неправильной реализации может так случится, что поток 1 после выполнения задачи, физически не возвращается в пул и через какое то время пул опустеет.

        ExecutorService fixedPool = Executors.newFixedThreadPool(2);
        // 3. Потоки которые НЕ по расписанию ТД может быть ExecutorService, это интерфейс. Далее прописываем класс Executors, там много всяких статических методов которыми можно воспользоваться, выбираем метод newFixedThreadPool(2), в аргументе указываем количество потоков (пока фиксированное). Затем можем передовать пул ЗАДАЧ.
                for (int i = 0; i < 7; i++) { // 4. можно передать задачи в цикле
            int iValue = i;

            fixedPool.execute(() -> { // 5. у ФИКСИРОВАННОГО пула потоков вызываем метод execute и в него передаются инструкции(задачи).
                // 6. Метод execute передает задачу в очередь, она попадает на исполнение в порядке своей очереди, а не нимедленно.
                System.out.println("Выполнение задачи №" + iValue);
            });
        }
        // 7. вариант без цикла.
        fixedPool.execute(() -> {
            System.out.println("Выполнение задачи № 1");
        });
        fixedPool.execute(() -> {
            System.out.println("Выполнение задачи № 2");
        });
        fixedPool.execute(() -> {
            System.out.println("Выполнение задачи № 3");
        });
        fixedPool.execute(() -> {
            System.out.println("Выполнение задачи № 4");
        });
        fixedPool.execute(() -> {
            System.out.println("Выполнение задачи №5 ");
        });
        // 9. Первый вариант.
        fixedPool.shutdown(); // 8. метод завершает задачи и не принимает новые и к пулу нельзя обращаться повторно (он закрыт). Нельзя вызвать fixedPool.execute(() -> {System.out.pr и т.д.
        //10. без остановке через .shutdown(), пул потоков будет ждать новых задач.

        // 11. второй ВАРИАНТ:
        List<Runnable> runeables = fixedPool.shutdownNow(); // 11. fixedPool.shutdownNow() - завершает текущие задачи в очереди и не принимает новые к пулу нельзя обратиться повторно. То есть мы получим список не выполненых задач - List<Runnable> runeables
        System.out.println(runeables);

        // 12. Второй способ создания пула потоков на один поток. Поток, который с одним потоком, который выполняет небольшие задачки
        ExecutorService singlePool = Executors.newSingleThreadExecutor(); //Создается вот так.

        // 13. задачи.
        singlePool.execute(() -> {
            System.out.println("Task 1");
        });
        singlePool.execute(() -> {
            System.out.println("Task 2");
        });

        //14. NB. Если в задачах имеется БЕСКОНЕЧНЫЙ ЦИКЛ, то singlePool.shutdown() - без NOW!!! НЕ завершит бесконечную задачу
        singlePool.shutdownNow(); //14. а метод shutdownNow() СКОРЕЕ ВСЕГО не завершит бесконечную задачу

        //15. NB Все планировщики НЕ связанные со временем это просто ExecutorsService
        //16. NB Планировщики связанные со временем используют данный интерфейс ScheduledExecutorService
        ScheduledExecutorService everySevenSecond = Executors.newSingleThreadScheduledExecutor();
        //17. В пуле будет один поток который будет выполнять задачи по расписанию.


        everySevenSecond.scheduleAtFixedRate(() -> {
                    System.out.println("scheduleFixedRate task"); // Runnable command - задача которая должна выполняться
                },
            0,          // 18. первоначальное время ожидания перед началом выполнения
                7,               // 19. long initialDelay - задача запускается на выполнение каждые 7
                TimeUnit.SECONDS // 20. каждые сек/мили/часы/дни (короче это раз в .....)
                // 21. NB Важный момент, метод не берет в расчет время выполнения задачи, то есть не важно выполнена ли задача, запуск повторится через 7мь сек и будет происходить переполение или поток не справится с задачей, что бы это избежать, необходимо учитывать время выполнения задачи.

        );
        ScheduledExecutorService everyThreeSecond = Executors.newSingleThreadScheduledExecutor();
        everyThreeSecond.scheduleWithFixedDelay( //22. метод берет в расчет время выполнения задач, аргументы аналогичные
                () -> {
                    try {
                        Thread.sleep(5000);
                        System.out.println("scheduleWithFixedDelay task");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                },

                0,               // 23. первоначальное время ожидания перед началом выполнения
                3,                        // 24. NB long delay - задача запускается на выполнение каждые 3, после завершения предыдущей!
                TimeUnit.SECONDS
        );
        // 25. можно завершить вызовом метода shutdown

        ScheduledExecutorService scheduledExecutor = Executors.newSingleThreadScheduledExecutor();
        scheduledExecutor.schedule(
                () -> { // 26. Runnable command - задача, которая выполняется
                    System.out.println("scheduledExecutor task");
                },
                10, // 27. long delay - время ОЖИДАНИЯ перед началом выполнения задачи (отложенное выполнение)
                TimeUnit.SECONDS

        );
        scheduledExecutor.shutdown();
//42.
        /* 2- изначальное количество потоков*/
        /* 7 - макс количество потоков*/
        ExecutorService lessonPool = new LessonExecutor(
                2,
                7,
                20, TimeUnit.SECONDS, /*поток ждет без задач, если задача не появилась поток удаляется из пула*/
                new LinkedBlockingQueue<>()); // 43. Блокирующая Очередь фиксированного или нет размера, можно передать все, что угодно, например, что Array не принемает больше 20 задач на вход.
        lessonPool.execute(() -> {
            try {
                Thread.sleep(200);
                System.out.println("lessonPool 1"); //44. задача
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        lessonPool.execute(() -> {
            System.out.println("lessonPool 2");
        });
        lessonPool.shutdown();
        //45. и завершаем shutdown(), что бы заверить программу и он не продолжал ждать задач.


    }
}
